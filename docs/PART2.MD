# Part 2: Query Development and Comparison

## Table des mati√®res

1. [Pr√©requis](#pr√©requis)
2. [Objectifs](#objectifs)
3. [R√©sultats de la recherche SIGMOD](#r√©sultats-de-la-recherche-sigmod)
4. [Cypher 25 : Solutions et nouvelles fonctionnalit√©s](#cypher-25--solutions-et-nouvelles-fonctionnalit√©s)
5. [Les 6 comparaisons obligatoires](#les-6-comparaisons-obligatoires)
6. [Application des patterns aux donn√©es IDFM](#application-des-patterns-aux-donn√©es-idfm)
7. [Strat√©gie de test et m√©triques](#strat√©gie-de-test-et-m√©triques)
8. [Notes d'impl√©mentation](#notes-dimpl√©mentation)
9. [R√©f√©rences](#r√©f√©rences)

---

## Pr√©requis

‚úÖ **Phase 1 compl√©t√©e** : Les donn√©es doivent √™tre charg√©es dans PostgreSQL ET Neo4j (voir `docs/PART1.MD`)

- **PostgreSQL** : Base relationnelle avec contraintes d'int√©grit√© et index
- **Neo4j** : Base graphe avec mod√®le hybride (Stop, Trip, Route, Agency)
- **Donn√©es** : Subsets IDFM (m√©tro) avec ~54k stops, ~15k trips, ~200k transfers

---

## Objectifs

Cette phase vise √† comparer **Cypher 5 vs Cypher 25 vs SQL vs GDS** √† travers :

1. **Identification des patterns probl√©matiques** de Cypher 5 (article SIGMOD)
2. **R√©√©criture en Cypher 25** avec nouvelles fonctionnalit√©s
3. **√âquivalents SQL** (CTEs r√©cursives notamment)
4. **Algorithmes GDS** (Graph Data Science)
5. **Tests sur donn√©es IDFM** de transport
6. **Analyse des plans d'ex√©cution** et performance

---

## R√©sultats de la recherche SIGMOD

### Le probl√®me fondamental

L'article **"Dangers of List Processing in Querying Property Graphs"** (SIGMOD) identifie un probl√®me majeur dans Cypher 5 :

> **L'utilisation de `reduce` dans les clauses `WHERE` cr√©e des requ√™tes NP-compl√®tes** qui :
> - Apparaissent simples syntaxiquement
> - Sont computationnellement intractables
> - Timeout sur des graphes minuscules
> - **93% des programmeurs ne peuvent pas pr√©dire leur performance**

### Les 6 patterns probl√©matiques

#### 1. **Hamiltonian Path** (Chemin hamiltonien)

**Probl√®me** : Trouver un chemin visitant tous les n≈ìuds exactement une fois

**Requ√™te probl√©matique** :
```cypher
MATCH p = (start)-[*]-(end)
WHERE size(nodes(p)) = <target_count>
  AND size(nodes(p)) = size(apoc.coll.toSet(nodes(p)))
RETURN p
```

**R√©sultats** :
- ‚è±Ô∏è Timeout √† partir de **‚â•10 n≈ìuds** (p=0.2 density)
- üî¥ Complexit√© exponentielle cach√©e derri√®re une syntaxe simple
- üìä L'utilisation combin√©e de `size()` et `all()` (variantes de `reduce`) cause le probl√®me

---

#### 2. **Subset Sum** (Somme de sous-ensemble)

**Probl√®me** : Trouver un chemin dont la somme des propri√©t√©s d'ar√™tes √©gale une valeur cible

**Requ√™te probl√©matique** :
```cypher
MATCH p = (s1)-[*]-(s2)
WHERE reduce(total = 0, r IN relationships(p) | total + r.weight) = <target>
RETURN p
```

**R√©sultats** :
- ‚è±Ô∏è Timeout √† partir de **‚â•27 n≈ìuds**
- üî¥ NP-complet m√™me avec s√©mantique de plus court chemin
- üìä La somme cible agit comme un pr√©dicat qui force l'exploration exhaustive

---

#### 3. **Data-Aware Path Queries** (Chemins sensibles aux donn√©es)

**Probl√®me** : Filtrer des chemins selon les valeurs de propri√©t√©s le long du chemin

**Exemples** :
- Chemins o√π les timestamps sont croissants
- Chemins o√π les poids alternent entre pairs/impairs
- Chemins sans ar√™tes cons√©cutives de m√™me type

**Requ√™te probl√©matique** :
```cypher
MATCH p = (s1)-[*]-(s2)
WHERE all(i IN range(0, size(relationships(p))-2) WHERE
  relationships(p)[i].timestamp < relationships(p)[i+1].timestamp)
RETURN p
```

**Issue** :
- Agr√©gation horizontale sur les √©l√©ments du chemin dans les filtres
- Force l'√©valuation de TOUS les chemins avant filtrage

---

#### 4. **Horizontal Aggregation** (Agr√©gation horizontale)

**Probl√®me** : R√©duire/agr√©ger sur les √©l√©ments d'un chemin dans un `WHERE`

**Exemples** :
- Compter les types de n≈ìuds diff√©rents dans un chemin
- Calculer la moyenne des propri√©t√©s
- V√©rifier des conditions sur les s√©quences

**Requ√™te probl√©matique** :
```cypher
MATCH p = (s)-[*]-(e)
WHERE reduce(count = 0, n IN nodes(p) WHERE n:Type1 | count + 1) > 5
RETURN p
```

**Issue** : Cr√©e des espaces de recherche exponentiels

---

#### 5. **Regular Path Queries (RPQs)** avec listes

**Probl√®me** : Patterns r√©guliers difficiles √† exprimer sans manipulation de listes

**Exemples** :
- `(aa)*` : s√©quences r√©p√©t√©es de m√™me label
- `(ab)+c` : alternance suivie d'un label sp√©cifique

**Requ√™te probl√©matique** :
```cypher
MATCH p = (s)-[*]-(e)
WHERE all(i IN range(0, size(relationships(p))-1) WHERE
  i % 2 = 0 IMPLIES type(relationships(p)[i]) = 'TYPE_A')
RETURN p
```

**Issue** : Manipulation complexe de listes requise, mieux vaut une syntaxe RPQ d√©di√©e

---

#### 6. **Trail Semantics** combin√©s avec listes

**Probl√®me** : Patterns trail (`A*BA*`) performent mal avec op√©rations sur listes

**D√©couverte cl√©** :
- ‚úÖ Trail semantics **seuls** sont OK : graphes 3√ó plus grands, <1ms
- üî¥ Combin√©s avec op√©rations listes : effondrement des performances

**Requ√™te probl√©matique** :
```cypher
MATCH p = TRAIL (s)-[*]-(hub)-[*]-(e)
WHERE size([n IN nodes(p) WHERE n:SmallCave]) <= 2
RETURN p
```

**Conclusion** : Les listes, pas les trails, causent l'effondrement

---

### Comparaison SQL

L'article compare √©galement avec PostgreSQL et DuckDB :

| Pattern | Neo4j Cypher 5 | SQL (PostgreSQL/DuckDB) | Verdict |
|---------|----------------|-------------------------|---------|
| Trail patterns (`A*BA*`) | ‚è±Ô∏è Timeout | ‚è±Ô∏è‚è±Ô∏è Timeout (pire) | **Neo4j gagne** |
| Hamiltonian path | ‚è±Ô∏è Timeout ‚â•10 n≈ìuds | ‚è±Ô∏è Timeout ‚â•12 n≈ìuds | **SQL l√©g√®rement meilleur** |
| Subset sum | ‚è±Ô∏è Timeout ‚â•27 n≈ìuds | ‚è±Ô∏è Timeout ‚â•30 n≈ìuds | **SQL l√©g√®rement meilleur** |

**Diff√©rence cl√©** : En SQL, il est **plus difficile d'√©crire des requ√™tes probl√©matiques par accident**
- Les CTEs r√©cursives forcent une structure explicite
- Moins de "sucre syntaxique" qui cache la complexit√©

---

### √âtude utilisateur (45 √©tudiants MSc)

R√©sultats r√©v√©lateurs :
- ‚úÖ **78%** ont correctement compris la requ√™te Hamiltonian path
- ‚úÖ **55%** ont pu √©crire correctement la requ√™te subset sum
- üî¥ **Seulement 7%** ont correctement estim√© le seuil de timeout
- üìä La plupart ont surestim√© de **2-3 ordres de grandeur**

**Conclusion** : Les d√©veloppeurs ne peuvent pas pr√©dire la complexit√© de leurs propres requ√™tes

---

### Le√ßons pour la conception de langages

#### Le√ßon 1 : Interdire `reduce` dans les clauses `WHERE`
- ‚ùå La compilation devrait √©chouer si `reduce` appara√Æt dans des filtres
- ‚ùå S'applique m√™me aux formes restreintes (`all`, `any`, `size`)
- ‚úÖ Cypher 25 impl√©mente cette restriction

#### Le√ßon 2 : Autoriser `reduce` dans les clauses de sortie avec restrictions
- ‚úÖ Safe dans `RETURN`, `WITH`
- ‚úÖ La sortie doit √™tre une valeur scalaire ou liste de scalaires
- ‚ùå Pas de listes imbriqu√©es (√©vite les requ√™tes powerset-style exponentielles)

#### Le√ßon 3 : Fournir des constructions sp√©cialis√©es au lieu de `reduce` g√©n√©ral
- ‚úÖ Pour les RPQs : syntaxe de patterns d√©di√©e (comme dans GQL/SQL/PGQ)
- ‚úÖ Pour les chemins complexes : fonctionnalit√©s linguistiques sp√©cifiques
- ‚ùå √âviter la tentation de copier l'approche par listes de Cypher 5

---

## Cypher 25 : Solutions et nouvelles fonctionnalit√©s

### Vue d'ensemble

Cypher 25 introduit plusieurs fonctionnalit√©s cl√©s pour r√©soudre les probl√®mes identifi√©s :

1. **`allReduce`** : Alternative s√ªre √† `reduce` dans `WHERE`
2. **Quantified Graph Patterns** : Syntaxe pour quantifier les patterns
3. **`REPEATABLE ELEMENTS`** : Match mode permettant la r√©p√©tition
4. **Trail Semantics natifs** : Support sans surcharge de listes
5. **`SHORTEST N PATHS` pond√©r√©** : Plus courts chemins avec poids
6. **Restrictions sur `reduce`** : Interdit dans `WHERE`, permis dans `RETURN/WITH`

---

### 1. `allReduce` - Safe Path Property Checking

**Syntaxe** :
```cypher
allReduce(
    accumulator = initial_value,
    element IN collection |
    expression,
    condition
)
```

**Exemple - Chemins avec propri√©t√©s croissantes** :
```cypher
CYPHER 25
MATCH p = (s1:Stop)-[:STOP_TIME*]->(t:Trip)
WHERE allReduce(
    prev = -1,
    rel IN relationships(p) |
    rel.stop_sequence,
    prev <= rel.stop_sequence
)
RETURN p LIMIT 10
```

**Avantages** :
- ‚úÖ √âlagage pendant la travers√©e (pas apr√®s)
- ‚úÖ R√©duit l'espace de recherche de millions √† milliers de chemins
- ‚úÖ Permet des limites de profondeur √©lev√©es sans timeout

**Performance** : Cas d'√©tude Advent of Code Day 12
- Cypher 5 (2021) : **144 secondes** (avec refactoring du graphe + APOC)
- Cypher 25 (2025) : **1.2 secondes** (graphe original, pas de refactoring)
- **Speedup : 120x**

---

### 2. `REPEATABLE ELEMENTS` - Match Mode

Permet la r√©p√©tition de n≈ìuds et relations dans un m√™me chemin.

**Cas d'usage** :

#### A. Pathfinding optimal avec contraintes

**Exemple** : Plus court chemin avec d√©tour obligatoire (station-service)

```cypher
CYPHER 25
MATCH REPEATABLE ELEMENTS
    route = ANY SHORTEST (:Start)--{,100}(:GasStation)--{,100}(:Stop)
RETURN length(route) AS length
```

Sans `REPEATABLE ELEMENTS`, impossible d'explorer les d√©tours (retour en arri√®re).

---

#### B. Covering Paths (Doctor's Rounds)

**Probl√®me** : Un m√©decin doit visiter tous les services d'un √©tage

```cypher
CYPHER 25
LET wards = COLLECT { MATCH (n:Ward) RETURN n }
MATCH REPEATABLE ELEMENTS ALL SHORTEST
    (p = (start {id: 1})--{,11}(start)
     WHERE all(ward IN wards WHERE ward IN nodes(p)))
RETURN [n IN nodes(p) | n.id] AS route
```

**R√©sultat** : Trouve les chemins optimaux m√™me si certains couloirs doivent √™tre parcourus 2 fois.

---

#### C. Peer-to-Peer Reachability (Famille)

**Probl√®me** : Trouver les petits-enfants partageant des grands-parents

```cypher
CYPHER 25
MATCH REPEATABLE ELEMENTS
    (kidA)-[:MOTHER|FATHER]->{2}(grandparent)<-[:MOTHER|FATHER]-{2}(kidB)
WHERE kidA < kidB
RETURN kidA.name, kidB.name, count(DISTINCT grandparent) AS shared_grandparents
```

Sans `REPEATABLE ELEMENTS`, impossible de remonter puis redescendre les m√™mes relations.

---

#### D. Grammar Generation

**Probl√®me** : G√©n√©rer tous les patterns Cypher valides de forme `()-->()`

```cypher
CYPHER 25
MATCH REPEATABLE ELEMENTS p = (:Start)-->{,9}(:End)
WITH [n IN nodes(p) | n.symbol] AS letters
RETURN reduce(acc = "", l IN letters | acc + l) AS pattern
```

G√©n√®re : `()`, `()-->()`, `()<--()`, `()--()-->()`, etc.

---

### 3. Quantified Graph Patterns

Syntaxe pour sp√©cifier des cardinalit√©s sur les patterns.

**Exemple - Trouver les hubs (‚â•3 connections)** :
```cypher
CYPHER 25
MATCH (s:Stop)
WHERE EXISTS { (s)-[:TRANSFER]->(:Stop) } >= 3
RETURN s.stop_name, count { (s)-[:TRANSFER]->() } AS connections
```

**√âquivalent Cypher 5 (moins clair)** :
```cypher
CYPHER 5
MATCH (s:Stop)
WITH s, count { (s)-[:TRANSFER]->() } AS cnt
WHERE cnt >= 3
RETURN s.stop_name, cnt
```

**Avantages Cypher 25** :
- Syntaxe plus expressive
- Intention plus claire
- Optimisation possible par le moteur

---

### 4. Trail Semantics Natifs

**Cypher 5** : N√©cessite `DIFFERENT RELATIONSHIPS` (mode par d√©faut)

**Cypher 25** : Support explicite avec `TRAIL`

```cypher
CYPHER 25
MATCH (hub:Stop {stop_name: 'Ch√¢telet'})
MATCH p = TRAIL (s1:Stop)-[:TRANSFER|STOP_TIME*]-(hub)-[:TRANSFER|STOP_TIME*]-(s2:Stop)
WHERE s1.stop_id < s2.stop_id
RETURN p LIMIT 100
```

**Performance** :
- Graphes 3√ó plus grands qu'en Cypher 5
- <1ms runtime
- **Condition** : Ne pas combiner avec op√©rations listes complexes

---

### 5. `SHORTEST N PATHS` avec pond√©ration

```cypher
CYPHER 25
MATCH (s:Stop {stop_name: 'Ch√¢telet'}), (e:Stop {stop_name: 'Nation'})
MATCH p = SHORTEST 5 PATHS (s)-[:TRANSFER*]-(e)
  WITH WEIGHT (r:TRANSFER | r.min_transfer_time)
RETURN p, reduce(total = 0, r IN relationships(p) | total + r.min_transfer_time) AS total_time
ORDER BY total_time
```

**Avantages** :
- Pond√©ration native (pas besoin de GDS pour cas simples)
- Top-K shortest paths
- Syntaxe d√©clarative

---

## Les 6 comparaisons obligatoires

D'apr√®s `CONSIGNES.MD`, le projet doit inclure au minimum :

### 1. ‚úÖ Increasing Property Paths (Cypher 5 vs 25 vs SQL)

**Objectif** : Chemins o√π une propri√©t√© d'ar√™te est croissante

**Propri√©t√© IDFM** : `stop_sequence` (ordre des arr√™ts dans un trajet)

**Fichiers** : `queries/01_increasing_paths.cypher`, `queries/01_increasing_paths.sql`

#### Cypher 5 - Version probl√©matique

```cypher
CYPHER 5
MATCH (r:Route {route_long_name: '11'})
MATCH (t:Trip)-[:BELONGS_TO]->(r)
MATCH p = (start:Stop)-[:STOP_TIME*]->(t)
WHERE NOT EXISTS {
    WITH p
    UNWIND range(0, length(p)-2) AS i
    WITH relationships(p)[i] AS r1, relationships(p)[i+1] AS r2
    WHERE r1.stop_sequence >= r2.stop_sequence
    RETURN 1
}
RETURN p LIMIT 10
```

**Probl√®mes** :
- `NOT EXISTS` avec it√©ration sur range + indexation
- Force l'√©valuation de TOUS les chemins avant filtrage
- Timeout attendu : >10 stops (selon SIGMOD)

---

#### Cypher 25 - Avec `allReduce`

```cypher
CYPHER 25
MATCH (r:Route {route_long_name: '11'})
MATCH (t:Trip)-[:BELONGS_TO]->(r)
MATCH p = (start:Stop)-[:STOP_TIME*]->(t)
WHERE allReduce(
    prev = -1,
    rel IN relationships(p) |
    rel.stop_sequence,
    prev <= rel.stop_sequence
)
RETURN p LIMIT 10
```

**Avantages** :
- √âlagage PENDANT la travers√©e
- Pas d'exploration de branches mortes
- G√®re des chemins plus longs

---

#### SQL - CTE R√©cursive

```sql
WITH RECURSIVE route_path AS (
    -- Cas de base : premier arr√™t de chaque trajet
    SELECT
        st.stop_id,
        st.trip_id,
        st.stop_sequence,
        st.departure_time,
        ARRAY[st.stop_id] AS path,
        1 AS length
    FROM stop_times st
    WHERE st.stop_sequence = 0

    UNION ALL

    -- Cas r√©cursif : arr√™ts suivants avec contrainte croissante
    SELECT
        st.stop_id,
        st.trip_id,
        st.stop_sequence,
        st.departure_time,
        rp.path || st.stop_id,
        rp.length + 1
    FROM route_path rp
    JOIN stop_times st
        ON rp.trip_id = st.trip_id
        AND st.stop_sequence = rp.stop_sequence + 1
    WHERE st.departure_time > rp.departure_time  -- Contrainte croissante
)
SELECT * FROM route_path
WHERE length >= 5
LIMIT 10;
```

**Avantages** :
- La contrainte est dans le `WHERE` du JOIN r√©cursif
- √âlagage naturel pendant la construction
- Performance similaire √† Cypher 25

---

### 2. ‚úÖ Quantified Graph Patterns (difficile sans cette fonctionnalit√©)

**Objectif** : D√©montrer l'utilit√© des quantified patterns

**Cas d'usage IDFM** : Trouver les hubs de correspondance (‚â•3 transfers)

#### Cypher 25 - Quantified Pattern

```cypher
CYPHER 25
MATCH (s:Stop)
WHERE EXISTS { (s)-[:TRANSFER]->(:Stop) } >= 3
RETURN s.stop_name,
       count { (s)-[:TRANSFER]->() } AS num_transfers
ORDER BY num_transfers DESC
```

---

#### Cypher 5 - Sans quantified patterns (workaround)

```cypher
CYPHER 5
MATCH (s:Stop)
WITH s, count { (s)-[:TRANSFER]->() } AS cnt
WHERE cnt >= 3
RETURN s.stop_name, cnt
ORDER BY cnt DESC
```

**Diff√©rences** :
- Cypher 25 : D√©claratif, condition dans le `WHERE` directement
- Cypher 5 : N√©cessite `WITH` interm√©diaire, moins lisible

---

#### SQL - GROUP BY HAVING

```sql
SELECT
    s.stop_name,
    COUNT(DISTINCT t.to_stop_id) AS num_transfers
FROM stops s
JOIN transfers t ON s.stop_id = t.from_stop_id
GROUP BY s.stop_id, s.stop_name
HAVING COUNT(DISTINCT t.to_stop_id) >= 3
ORDER BY num_transfers DESC;
```

**Note** : SQL a toujours eu `HAVING`, donc pas de probl√®me ici

---

### 3. ‚úÖ Shortest Path Algorithms (Cypher 5 vs 25 vs GDS vs SQL)

**Objectif** : Comparer TOUTES les variantes de plus courts chemins

#### A. Cypher 5 - BFS non pond√©r√©

```cypher
CYPHER 5
MATCH (s:Stop {stop_name: 'Ch√¢telet'}), (e:Stop {stop_name: 'Nation'})
MATCH p = shortestPath((s)-[:TRANSFER*]-(e))
RETURN p, length(p) AS hops
```

**Algorithme** : BFS unidirectionnel ou bidirectionnel (selon heuristique)

---

```cypher
CYPHER 5
MATCH (s:Stop {stop_name: 'Ch√¢telet'}), (e:Stop {stop_name: 'Nation'})
MATCH p = allShortestPaths((s)-[:TRANSFER*]-(e))
RETURN p, length(p) AS hops
```

**Retourne** : TOUS les chemins de longueur minimale

---

#### B. Cypher 25 - BFS pond√©r√©

```cypher
CYPHER 25
MATCH (s:Stop {stop_name: 'Ch√¢telet'}), (e:Stop {stop_name: 'Nation'})
MATCH p = SHORTEST 5 PATHS (s)-[:TRANSFER*]-(e)
  WITH WEIGHT (r:TRANSFER | r.min_transfer_time)
RETURN p,
       reduce(total = 0, r IN relationships(p) | total + r.min_transfer_time) AS total_time
ORDER BY total_time
```

**Avantages** :
- Top-K shortest paths
- Pond√©ration native
- Retourne les K meilleurs chemins tri√©s

---

#### C. GDS - Algorithmes sp√©cialis√©s

**Fichier** : `queries/04_shortest_path_gds.cypher`

##### Dijkstra (pond√©r√©)

```cypher
// 1. Cr√©er projection
CALL gds.graph.project(
    'transport-weighted',
    'Stop',
    {
        TRANSFER: {
            properties: ['min_transfer_time']
        }
    }
)

// 2. Dijkstra
MATCH (s:Stop {stop_name: 'Ch√¢telet'}), (e:Stop {stop_name: 'Nation'})
CALL gds.shortestPath.dijkstra.stream('transport-weighted', {
    sourceNode: s,
    targetNode: e,
    relationshipWeightProperty: 'min_transfer_time'
})
YIELD path, totalCost
RETURN path, totalCost
```

---

##### A* (avec heuristique g√©ographique)

```cypher
MATCH (s:Stop {stop_name: 'Ch√¢telet'}), (e:Stop {stop_name: 'Nation'})
CALL gds.shortestPath.astar.stream('transport-weighted', {
    sourceNode: s,
    targetNode: e,
    latitudeProperty: 'stop_lat',
    longitudeProperty: 'stop_lon',
    relationshipWeightProperty: 'min_transfer_time'
})
YIELD path, totalCost
RETURN path, totalCost
```

**Avantage A*** : Heuristique distance euclidienne r√©duit l'espace de recherche

---

##### Yen's K-Shortest Paths

```cypher
MATCH (s:Stop {stop_name: 'Ch√¢telet'}), (e:Stop {stop_name: 'Nation'})
CALL gds.shortestPath.yens.stream('transport-weighted', {
    sourceNode: s,
    targetNode: e,
    k: 5,
    relationshipWeightProperty: 'min_transfer_time'
})
YIELD path, totalCost
RETURN path, totalCost
ORDER BY totalCost
```

**Retourne** : Les K meilleurs chemins (pas seulement longueur minimale)

---

##### All Pairs Shortest Path ‚ö†Ô∏è

```cypher
CALL gds.allShortestPaths.dijkstra.stream('transport-weighted', {
    relationshipWeightProperty: 'min_transfer_time'
})
YIELD sourceNode, targetNode, totalCost, path
RETURN gds.util.asNode(sourceNode).stop_name AS from_stop,
       gds.util.asNode(targetNode).stop_name AS to_stop,
       totalCost
LIMIT 100
```

**Attention** :
- Complexit√© O(n¬≤) en m√©moire
- Sur 54k stops ‚Üí 54k √ó 54k = 2.9 milliards de paires
- **Utiliser seulement sur sous-graphes**

---

#### D. SQL - CTE R√©cursive (approximation BFS)

```sql
WITH RECURSIVE shortest_path AS (
    -- Cas de base : d√©part
    SELECT
        t1.from_stop_id AS current_stop,
        t1.to_stop_id AS next_stop,
        t1.min_transfer_time AS total_time,
        ARRAY[t1.from_stop_id] AS path,
        1 AS depth
    FROM transfers t1
    JOIN stops s ON t1.from_stop_id = s.stop_id
    WHERE s.stop_name = 'Ch√¢telet'

    UNION ALL

    -- Cas r√©cursif : expansion
    SELECT
        sp.next_stop,
        t.to_stop_id,
        sp.total_time + t.min_transfer_time,
        sp.path || sp.next_stop,
        sp.depth + 1
    FROM shortest_path sp
    JOIN transfers t ON sp.next_stop = t.from_stop_id
    WHERE NOT (t.to_stop_id = ANY(sp.path))  -- √âviter cycles
      AND sp.depth < 10  -- Limite profondeur
)
SELECT
    sp.path || sp.next_stop AS full_path,
    sp.total_time,
    sp.depth AS hops
FROM shortest_path sp
JOIN stops s ON sp.next_stop = s.stop_id
WHERE s.stop_name = 'Nation'
ORDER BY sp.total_time
LIMIT 5;
```

**Limitations** :
- Pas de vrai Dijkstra (explore par niveaux BFS-style)
- Peut manquer le chemin optimal si profondeur limit√©e trop stricte
- Performance variable selon les index

---

#### Comparaison des algorithmes

| Algorithme | Complexit√© | Pond√©r√© | Top-K | Heuristique | Usage |
|------------|-----------|---------|-------|-------------|-------|
| BFS (Cypher 5 `shortestPath`) | O(V+E) | ‚ùå | ‚ùå | ‚ùå | Chemins simples |
| BFS (Cypher 5 `allShortestPaths`) | O(V+E) | ‚ùå | ‚úÖ (tous) | ‚ùå | Tous les plus courts |
| Cypher 25 `SHORTEST N` | O(V+E) | ‚úÖ | ‚úÖ | ‚ùå | Top-K pond√©r√©s |
| Dijkstra (GDS) | O((V+E)logV) | ‚úÖ | ‚ùå | ‚ùå | Plus court pond√©r√© |
| A* (GDS) | O((V+E)logV) | ‚úÖ | ‚ùå | ‚úÖ (geo) | Optimis√© g√©o |
| Yen's K-Shortest (GDS) | O(K√óV√ó(E+VlogV)) | ‚úÖ | ‚úÖ | ‚ùå | K meilleurs chemins |
| SQL CTE R√©cursive | O(V+E) par niveau | ‚ö†Ô∏è (approx) | ‚ö†Ô∏è | ‚ùå | Graphes simples |

---

#### Analyse des plans d'ex√©cution

**Question cl√©** : BFS unidirectionnel vs bidirectionnel ?

##### BFS Unidirectionnel
```
Start ‚Üí explore niveau 1 ‚Üí niveau 2 ‚Üí ... ‚Üí Target
```
- **Espace explor√©** : O(b^d) o√π b=branching factor, d=profondeur
- **Usage** : Quand target est proche, ou graphe peu dense

##### BFS Bidirectionnel
```
Start ‚Üí niveau 1 ‚Üê
          ‚Üì       ‚Üë
      niveau 2   niveau 2
          ‚Üì       ‚Üë
          ‚Üí Meet ‚Üê Target
```
- **Espace explor√©** : O(2 √ó b^(d/2)) = O(b^(d/2)) (beaucoup plus petit!)
- **Usage** : Quand target est loin, graphe dense
- **Condition** : Les deux n≈ìuds doivent √™tre connus √† l'avance

**Neo4j choisit automatiquement** selon :
- Distance estim√©e entre n≈ìuds
- Branching factor
- Statistiques du graphe

**Comment v√©rifier** : Utiliser `PROFILE` et chercher :
- `BidirectionalShortestPath` operator
- `ExpandAll` directions (vers avant/arri√®re)

---

### 4. ‚úÖ GDS Implementation in Cypher 25

**Objectif** : Impl√©menter en Cypher pur des algorithmes disponibles dans GDS

**Exemple** : Dijkstra na√Øf en Cypher 25

```cypher
CYPHER 25
// Version simplifi√©e de Dijkstra en pur Cypher
MATCH (source:Stop {stop_name: 'Ch√¢telet'})
CALL {
    WITH source
    MATCH p = (source)-[:TRANSFER*]-(target:Stop)
    WITH target,
         reduce(cost = 0, r IN relationships(p) | cost + r.min_transfer_time) AS total_cost,
         p
    ORDER BY total_cost ASC
    LIMIT 1
    RETURN target, total_cost, p
}
RETURN target.stop_name, total_cost, p
```

**Comparaison** :

| Aspect | Cypher Natif | GDS Dijkstra |
|--------|--------------|--------------|
| **Performance** | ‚è±Ô∏è Plus lent (explore tous chemins) | ‚úÖ Optimis√© (priority queue) |
| **M√©moire** | ‚ö†Ô∏è Stocke tous les chemins | ‚úÖ Stocke seulement distances |
| **Simplicit√©** | ‚úÖ Code Cypher pur | ‚ùå N√©cessite projection GDS |
| **Flexibilit√©** | ‚úÖ Filtres complexes faciles | ‚ö†Ô∏è Limit√© √† propri√©t√©s de la projection |

**Cas d'usage Cypher natif** :
- Graphes tr√®s petits (<1000 n≈ìuds)
- Logique m√©tier complexe (filtres, transformations)
- Prototypage rapide

**Cas d'usage GDS** :
- Graphes larges (>10k n≈ìuds)
- Performance critique
- Algorithmes batch (All Pairs, PageRank, etc.)

---

### 5. ‚úÖ SQL Comparisons (CTEs r√©cursives)

**D√©j√† couvert dans les sections pr√©c√©dentes** :
- ‚úÖ Increasing paths : CTE r√©cursive avec contrainte croissante
- ‚úÖ Shortest path : CTE r√©cursive approximation BFS

**Autre exemple** : Calcul de profondeur de hi√©rarchie

```sql
-- Profondeur des stations dans le r√©seau (via parent_station)
WITH RECURSIVE hierarchy AS (
    -- Racines (pas de parent)
    SELECT stop_id, stop_name, parent_station, 0 AS depth
    FROM stops
    WHERE parent_station IS NULL

    UNION ALL

    -- Enfants
    SELECT s.stop_id, s.stop_name, s.parent_station, h.depth + 1
    FROM stops s
    JOIN hierarchy h ON s.parent_station = h.stop_id
)
SELECT stop_name, depth
FROM hierarchy
ORDER BY depth DESC, stop_name;
```

**Quand SQL est meilleur que Cypher** :
- Agr√©gations complexes (GROUP BY, WINDOW functions)
- Requ√™tes purement tabulaires (pas de travers√©e de graphe)
- Compatibilit√© avec outils BI existants

---

### 6. ‚úÖ Execution Plan Analysis (BFS uni vs bidirectionnel)

**D√©j√† couvert dans section 3.D**

**Comment analyser** :

#### Neo4j - PROFILE

```cypher
PROFILE
MATCH (s:Stop {stop_name: 'Ch√¢telet'}), (e:Stop {stop_name: 'Nation'})
MATCH p = shortestPath((s)-[:TRANSFER*]-(e))
RETURN p
```

**Chercher dans le plan** :
- Operator : `BidirectionalShortestPath` ou `ExpandAll`
- `db hits` : nombre d'acc√®s base
- `rows` : cardinalit√© estim√©e/r√©elle
- `EstimatedRows` vs `Rows` : pr√©cision des statistiques

---

#### PostgreSQL - EXPLAIN ANALYZE

```sql
EXPLAIN ANALYZE
WITH RECURSIVE shortest_path AS (
    ...
)
SELECT * FROM shortest_path;
```

**Chercher dans le plan** :
- Type de join : `Hash Join`, `Nested Loop`, `Merge Join`
- Index scans : `Index Scan` (bon) vs `Seq Scan` (mauvais pour grandes tables)
- `actual time` : temps r√©el d'ex√©cution
- `rows` : nombre de lignes trait√©es

---

## Application des patterns aux donn√©es IDFM

### Pattern suppl√©mentaire : Subset Sum (NP-complet)

**Probl√®me** : Trouver des s√©quences de correspondances totalisant exactement N secondes

#### Cypher 5 - Version probl√©matique

```cypher
CYPHER 5
MATCH p = (s1:Stop)-[:TRANSFER*]-(s2:Stop)
WHERE reduce(total = 0, r IN relationships(p) | total + r.min_transfer_time) = 300
RETURN p
```

**Timeout attendu** : ‚â•27 n≈ìuds (selon SIGMOD)

---

#### Cypher 25 - Solution partielle (d√©placer reduce)

```cypher
CYPHER 25
MATCH p = (s1:Stop)-[:TRANSFER*..5]-(s2:Stop)
WITH p, reduce(total = 0, r IN relationships(p) | total + r.min_transfer_time) AS total_time
WHERE total_time = 300
RETURN p
```

**Am√©lioration** :
- `reduce` dans `WITH` (pas `WHERE`)
- Limite de profondeur stricte (`*..5`)
- Toujours lent, mais termine

**Note** : Subset Sum reste NP-complet, aucune solution miracle

---

### Pattern suppl√©mentaire : Hamiltonian-style (visiter tous les arr√™ts d'une ligne)

**Probl√®me** : Trajet visitant TOUS les arr√™ts d'une ligne exactement une fois

#### Cypher 5 - Version probl√©matique

```cypher
CYPHER 5
MATCH (r:Route {route_long_name: '11'})
MATCH (s:Stop)-[:STOP_TIME]->(:Trip)-[:BELONGS_TO]->(r)
WITH collect(DISTINCT s) AS all_stops, count(DISTINCT s) AS target_count

MATCH p = (start:Stop)-[:STOP_TIME*]->(t:Trip)-[:BELONGS_TO]->(r)
WHERE size(nodes(p)) = target_count
  AND size(nodes(p)) = size(apoc.coll.toSet(nodes(p)))  -- Tous distincts
RETURN p LIMIT 1
```

**Timeout attendu** : ‚â•10 arr√™ts (selon SIGMOD)

---

#### Cypher 25 - Trail Semantics

```cypher
CYPHER 25
MATCH (r:Route {route_long_name: '11'})
LET target_count = count { (s:Stop)-[:STOP_TIME]->(:Trip)-[:BELONGS_TO]->(r) }

MATCH p = TRAIL (start:Stop)-[:STOP_TIME*]->(t:Trip)-[:BELONGS_TO]->(r)
WHERE length(p) = target_count
RETURN p LIMIT 1
```

**Avantages** :
- `TRAIL` garantit pas de r√©p√©tition de relations
- Plus performant que v√©rification manuelle avec `apoc.coll.toSet`
- Toujours NP-complet, mais exploration plus efficace

---

### Pattern suppl√©mentaire : RPQ (Sequences r√©guli√®res)

**Probl√®me** : Trouver des s√©quences de m√™me type de route (bus-bus-bus)

#### Cypher 25 - RPQ Syntax

```cypher
CYPHER 25
// S√©quences de ‚â•3 bus cons√©cutifs
MATCH (s1:Stop)-[:STOP_TIME]->(:Trip)-[:BELONGS_TO]->(r:Route {route_type: 3}){3,}
      -[:BELONGS_TO]<-(:Trip)<-[:STOP_TIME]-(s2:Stop)
RETURN s1.stop_name, s2.stop_name
```

**Syntaxe** : `{3,}` = r√©p√©ter 3 fois ou plus (comme regex `{3,}`)

---

#### Cypher 5 - Workaround avec listes

```cypher
CYPHER 5
MATCH p = (s1:Stop)-[:STOP_TIME*3..10]-(s2:Stop)
WHERE all(rel IN relationships(p) WHERE
    EXISTS { (rel)-[]->(:Trip)-[:BELONGS_TO]->(:Route {route_type: 3}) }
)
RETURN s1.stop_name, s2.stop_name
```

**Probl√®mes** :
- Syntaxe lourde
- Performance d√©grad√©e
- Moins lisible

---

## Strat√©gie de test et m√©triques

### Phase 1 : Tests fonctionnels

#### Objectifs
- ‚úÖ V√©rifier que chaque requ√™te s'ex√©cute sans erreur
- ‚úÖ Comparer r√©sultats Cypher vs SQL (coh√©rence)
- ‚úÖ Valider l'int√©grit√© des donn√©es

#### Actions
1. Ex√©cuter toutes les requ√™tes dans `queries/`
2. Pour patterns √©quivalents (Cypher vs SQL), comparer les r√©sultats :
   - M√™me nombre de lignes ?
   - M√™mes chemins trouv√©s ?
   - M√™mes co√ªts calcul√©s ?
3. Documenter les divergences (si any)

---

### Phase 2 : Tests de performance

#### M√©triques √† collecter

| M√©trique | Neo4j | PostgreSQL |
|----------|-------|------------|
| **Temps d'ex√©cution** | Timestamp d√©but/fin | `\timing on` |
| **Plan d'ex√©cution** | `PROFILE` | `EXPLAIN ANALYZE` |
| **M√©moire** | Java heap usage (Neo4j Desktop) | `work_mem` settings |
| **Db hits** | Dans `PROFILE` | N/A |
| **Lignes trait√©es** | `rows` dans plan | `rows` dans plan |
| **Algorithme utilis√©** | Operator name | Join type |

---

#### Proc√©dure de test progressif

**Pour chaque pattern probl√©matique** :

1. **D√©marrer petit** : Limiter √† 1 ligne de m√©tro (ligne 11 par exemple)
2. **Augmenter progressivement** :
   - 1 ligne ‚Üí timeout ? Non ‚Üí continuer
   - 2 lignes ‚Üí timeout ? Non ‚Üí continuer
   - Toutes lignes m√©tro ‚Üí timeout ? OUI ‚Üí documenter seuil
3. **Identifier le seuil de timeout** :
   - Nombre de n≈ìuds du graphe √† ce seuil
   - Comparer avec SIGMOD (Hamiltonian ‚â•10, Subset Sum ‚â•27)

**Exemple** :
```bash
# Test ligne 11 uniquement
METRO_LINES="11" ./generate_subset_files.sh

# Charger dans Neo4j, tester requ√™tes, mesurer temps
# Si OK, augmenter :

METRO_LINES="11 3" ./generate_subset_files.sh
# Recharger, retester

# R√©p√©ter jusqu'√† timeout
```

---


---

### Phase 3 : Analyse des plans d'ex√©cution

#### Questions cl√©s

##### 1. Cypher - BFS unidirectionnel vs bidirectionnel

**Exp√©rience** :
```cypher
// Test 1 : N≈ìuds proches (m√™me ligne)
PROFILE
MATCH (s:Stop {stop_name: 'R√©publique'}), (e:Stop {stop_name: 'Bastille'})
MATCH p = shortestPath((s)-[:TRANSFER*]-(e))
RETURN p

// Test 2 : N≈ìuds √©loign√©s (lignes diff√©rentes)
PROFILE
MATCH (s:Stop {stop_name: 'La D√©fense'}), (e:Stop {stop_name: 'Ch√¢teau de Vincennes'})
MATCH p = shortestPath((s)-[:TRANSFER*]-(e))
RETURN p
```

**Chercher dans PROFILE** :
- Operator : `BidirectionalShortestPath` (test 2) vs `ExpandAll` (test 1) ?
- `db hits` : combien plus √©lev√© dans test 2 ?

---

##### 2. Impact de `reduce` dans WHERE vs WITH

**Exp√©rience** :
```cypher
// Version 1 : reduce dans WHERE (probl√©matique)
PROFILE
MATCH p = (s:Stop)-[:TRANSFER*..5]-(e:Stop)
WHERE reduce(total = 0, r IN relationships(p) | total + r.min_transfer_time) < 600
RETURN count(p)

// Version 2 : reduce dans WITH
PROFILE
MATCH p = (s:Stop)-[:TRANSFER*..5]-(e:Stop)
WITH p, reduce(total = 0, r IN relationships(p) | total + r.min_transfer_time) AS total_time
WHERE total_time < 600
RETURN count(p)
```

**Attendre** : Version 2 devrait √™tre plus rapide (selon SIGMOD)

**Note** : Sur Neo4j 5.x, la diff√©rence peut √™tre minime car optimiseur moderne. L'article SIGMOD teste sur versions plus anciennes.

---

##### 3. SQL - Recursive CTE performance

**Exp√©rience** :
```sql
-- Mesurer impact de la profondeur max
\timing on

-- Profondeur 5
WITH RECURSIVE path AS (...) WHERE depth < 5
-- Noter temps

-- Profondeur 10
WITH RECURSIVE path AS (...) WHERE depth < 10
-- Noter temps

-- Profondeur 20
WITH RECURSIVE path AS (...) WHERE depth < 20
-- Noter temps
```

**Analyser** :
- Croissance exponentielle ?
- Lin√©aire ?
- Impact des index sur `stop_id`, `trip_id` ?

---

##### 4. GDS vs Cypher natif

**Exp√©rience** :
```cypher
// Dijkstra natif Cypher (approximation)
:param start => 'Ch√¢telet'
:param end => 'Nation'
PROFILE
MATCH (s:Stop {stop_name: $start}), (e:Stop {stop_name: $end})
MATCH p = (s)-[:TRANSFER*]-(e)
WITH p, reduce(cost = 0, r IN relationships(p) | cost + r.min_transfer_time) AS total_cost
ORDER BY total_cost LIMIT 1
RETURN p, total_cost

// vs GDS Dijkstra
PROFILE
MATCH (s:Stop {stop_name: $start}), (e:Stop {stop_name: $end})
CALL gds.shortestPath.dijkstra.stream('transport-weighted', {
    sourceNode: s,
    targetNode: e,
    relationshipWeightProperty: 'min_transfer_time'
})
YIELD path, totalCost
RETURN path, totalCost
```

**Comparer** :
- Temps d'ex√©cution
- M√©moire utilis√©e
- Complexit√© du plan

**Attendu** : GDS beaucoup plus rapide (algorithme optimis√©)

---

## Notes d'impl√©mentation

### APOC Functions

Certaines requ√™tes utilisent APOC (Advanced Procedures and Functions) :
- `apoc.coll.toSet` : convertir liste en ensemble (√©liminer doublons)
- `apoc.coll.occurrences` : compter occurrences dans liste
- `apoc.coll.duplicates` : trouver doublons

**Installation** :
1. Neo4j Desktop ‚Üí Database ‚Üí Plugins ‚Üí APOC
2. Restart database

**Alternatives natives** (si APOC indisponible) :
```cypher
// apoc.coll.toSet(list)
// ‚Üí utiliser reduce avec accumulation conditionnelle
UNWIND list AS item
WITH DISTINCT item
RETURN collect(item) AS set_list
```

---

### GDS Plugin Installation

**Pr√©requis** : N√©cessaire pour `04_shortest_path_gds.cypher`

**Installation** :
1. Neo4j Desktop ‚Üí Database ‚Üí Plugins ‚Üí Graph Data Science
2. Restart database
3. V√©rifier : `RETURN gds.version()`

**Versions** :
- Neo4j 5.x ‚Üí GDS 2.x
- Compatibilit√© : v√©rifier [GDS compatibility matrix](https://neo4j.com/docs/graph-data-science/current/installation/)

---

### Limits et Timeouts

**Neo4j** :
```properties
# neo4j.conf
dbms.transaction.timeout=300s
dbms.memory.heap.initial_size=2G
dbms.memory.heap.max_size=4G
```

**PostgreSQL** :
```sql
-- Session level
SET statement_timeout = '300s';
SET work_mem = '256MB';

-- V√©rifier
SHOW statement_timeout;
```

**Timeout progressif** :
1. D√©marrer avec timeout court (30s) pour tests fonctionnels
2. Augmenter pour tests de performance (300s)
3. Pour benchmark timeout : utiliser 600s (10 min) comme limite absolue

---

### Subsets de donn√©es

**Rappel** : Le script `generate_subset_files.sh` permet de cr√©er des subsets contr√¥l√©s

```bash
# Ligne 11 uniquement (~1.5k trips)
METRO_LINES="11" ./generate_subset_files.sh

# Lignes 3, 7, 14, 11 (default, ~15k trips)
./generate_subset_files.sh

# Toutes les lignes de m√©tro (~50k trips)
METRO_LINES="1 2 3 3b 4 5 6 7 7b 8 9 10 11 12 13 14" ./generate_subset_files.sh
```

**Strat√©gie recommand√©e** :
- Tests fonctionnels : 1 ligne
- Tests performance initiaux : 4 lignes (default)
- Tests limites (timeout) : augmenter jusqu'√† timeout
- Rapport : documenter les seuils trouv√©s

---

## R√©f√©rences

### Articles
- **SIGMOD** : `article/SIGMOD.MD` - Dangers of List Processing in Querying Property Graphs
- **Cypher 25 Case Study** : `article/SOLVE_HARD_GRAPH_PROBLEMS_WITH_CYPHER_25.MD` - Advent of Code Day 12, speedup 120x
- **REPEATABLE ELEMENTS** : `article/QUERY_CHOMP_REPEAT.MD` - Doctor's rounds, Pac-Man, Gas station detour

### Documentation projet
- **Part 1** : `docs/PART1.MD` - Data import strategy
- **Datasets** : `docs/DATASETS.MD` - GTFS schema reference
- **Queries** : `queries/README.md` - Implementation guide

### Documentation externe
- **Neo4j Cypher Manual** : https://neo4j.com/docs/cypher-manual/current/
- **Neo4j GDS** : https://neo4j.com/docs/graph-data-science/current/
- **PostgreSQL Recursive CTEs** : https://www.postgresql.org/docs/current/queries-with.html
- **GTFS Specification** : https://gtfs.org/

### Cours
- Cours "Bases de Donn√©es Sp√©cialis√©es" - Mod√©lisation graphe, optimisation requ√™tes
- R√©f√©rencer dans le rapport pour justifier choix de mod√©lisation

---

## R√©sum√© des livrables attendus

Pour le **rapport final** (Part 3), cette phase doit fournir :

### 1. R√©sultats exp√©rimentaux
- ‚úÖ Tableau comparatif Cypher 5 vs 25 vs SQL vs GDS
- ‚úÖ Temps d'ex√©cution pour chaque pattern
- ‚úÖ Seuils de timeout identifi√©s
- ‚úÖ Comparaison avec benchmarks SIGMOD

### 2. Plans d'ex√©cution
- ‚úÖ Captures d'√©cran Neo4j `PROFILE`
- ‚úÖ Captures PostgreSQL `EXPLAIN ANALYZE`
- ‚úÖ Analyse des algorithmes utilis√©s (BFS uni/bidirectional, etc.)
- ‚úÖ Comparaison db hits, m√©moire, cardinalit√©s

### 3. Analyses qualitatives
- ‚úÖ Quels patterns sont probl√©matiques et pourquoi ?
- ‚úÖ Cypher 25 r√©sout-il ces probl√®mes ? (th√©oriquement, bas√© sur articles)
- ‚úÖ Dans quels cas SQL est meilleur ?
- ‚úÖ Quand utiliser GDS vs Cypher natif ?

### 4. Code source
- ‚úÖ Tous les fichiers `.cypher` et `.sql` dans `queries/`
- ‚úÖ Scripts de test
- ‚úÖ Commentaires expliquant chaque requ√™te

### 5. Recommandations
- ‚úÖ Meilleures pratiques Cypher (√©viter `reduce` dans `WHERE`, etc.)
- ‚úÖ Quand choisir PostgreSQL vs Neo4j
- ‚úÖ Optimisations possibles (index, projections GDS, etc.)

---

**Prochaine √©tape** : Phase 3 - Ex√©cution des tests et r√©daction du rapport
